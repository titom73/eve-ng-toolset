#!/usr/bin/python
# coding: utf-8 -*-
#
# Copyright 2021 Arista Networks Thomas Grimonet
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http: //www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from __future__ import absolute_import, division, print_function

import argparse
import json
import os
import subprocess
import sys
from datetime import datetime

import requests
from prettytable import PrettyTable
from jinja2 import Template

ITERM2_PATH = 'Library/Application Support/iTerm2/DynamicProfiles'
ITERM2_PROFILE ='''
{
  "Profiles": [
    {% for node in nodes %}
    {
      "Name" : "{{ node[0] }}",
      "Tags" : ["{{ lab }}-{{ node[1] }}"],
      "Initial Text" : "telnet {{ eve }} {{ node[2] }}",
      "Guid": "{{ node[3] }}"
    },
    {%- endfor %}
  ]
}
'''


def iterm_profile(lab_json):
    nodelist = []
    for node in nodes['data'].keys():
        # running nodes only
        if lab_json['data'][node]['url'].split(':')[2] != '0':
            name = lab_json['data'][node]['name']               # node name
            # template: xrv, vios, etc
            type = lab_json['data'][node]['template']
            tport = lab_json['data'][node]['url'].split(':')[2]  # dynamic telnet port
            uuid = lab_json['data'][node]['uuid']               # node uuid
            nodelist.append((name, type, tport, uuid))

    template = Template(ITERM2_PROFILE)
    profile_name = args.lab.split('/')[-1]
    render = template.render(nodes=sorted(
        nodelist), lab=profile_name, eve=args.server)
    rfile = f'{os.path.expanduser("~")}/{ITERM2_PATH}/{profile_name}.json'
    print('Create iTerm2 dynamic profile at {}'.format(rfile))
    with open(rfile, 'w') as f:
        f.write(render)


def api_login(username, password, ip, ssl_check=False):
    data = {"username": username, "password": password, "html5": "-1"}
    url = 'https://{}/api/auth/login'.format(ip)
    login = requests.post(url=url, data=json.dumps(data), verify=ssl_check)
    if login.status_code == 200:
        cookies = login.cookies
    else:
        print(login.status_code, "Login Failure.",)
        exit(1)
    return cookies


def query_api(server, url, time_stamp, cookie, ssl_check=False):
    headers = {
        'Connection': 'keep-alive',
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'DNT': '1',
        'X-Requested-With': 'XMLHttpRequest',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',
        'Referer': 'https://{}/legacy/'.format(server),
        'Accept-Language': 'en-US,en;q=0.9',
    }
    api_url = 'https://{}/api/'.format(server)
    full_url = api_url + url + '?_={}'.format(time_stamp)
    nodes = requests.get(url=full_url, headers=headers,
                         cookies=cookie, verify=ssl_check)
    response = nodes.json()
    return response


def list_topology_nodes(lab_json):
    nodelist = []
    for node in lab_json['data'].keys():
        if lab_json['data'][node]['url'].split(':')[2] != '0':
            name = lab_json['data'][node]['name']
            template = lab_json['data'][node]['template']
            tport = lab_json['data'][node]['url'].split(':')[2]
            # tport = 'telnet://' + args.server + ':' + \
            lab_json['data'][node]['url'].split(':')[2]
            nodelist.append((args.lab.split('/')[-1], name, template, tport))

    table = PrettyTable(['Topology', 'Node Name', 'Type', 'Telnet Port'])
    for row in nodelist:
        table.add_row(row)
    return table


def connect_node(lab_json, node_search):
    for node in lab_json['data'].keys():
        if nodes['data'][node]['url'].split(':')[2] != '0' and nodes['data'][node]['name'] == node_search:
            tport = nodes['data'][node]['url'].split(':')[2]
            process = subprocess.run(['telnet', args.server, tport])
            process
    return True


if __name__ == '__main__':

    requests.packages.urllib3.disable_warnings()

    parser = argparse.ArgumentParser(
        description='EVE-NG Remote Access Topology')
    parser.add_argument(
        '--server', '-s', help='EVE-NG server', default='eve-ng.lab.local')
    parser.add_argument(
        '--username', '-u', help='Username to connect to EVE-NG', default='admin')
    parser.add_argument(
        '--password', '-p', help='Password to connect to EVE-NG - can be set with EVE_PASSWORD env')
    parser.add_argument(
        '--lab', '-l', help='LAB name without extension running on EVE-NG', default='password')
    parser.add_argument(
        '--connect', '-c', help='Connect to node', default='unset')
    parser.add_argument(
        '--iterm', help='Generate iTerm2 profile', action="store_true", default=False)
    args = parser.parse_args()

    args.password = os.getenv('EVE_PASSWORD', args.password)

    eve_credentials = b'{"username": "+ args.username +", "password": "+ args.password +", "html5": "-1"}'
    eve_authurl = f'https://{args.server}/api/auth/login'
    eve_folders = 'folders/Users/Customers'
    eve_status = 'status'
    eve_lab = 'labs/{}.unl/nodes'.format(args.lab)
    now = datetime.now()
    time_stamp = int(datetime.timestamp(now) * 1000)

    print('Getting information from {}'.format(args.server))

    cookie = api_login(username=args.username, password=args.password, ip=args.server)
    nodes = query_api(server=args.server, url=eve_lab,
                      time_stamp=time_stamp, cookie=cookie)
    if args.connect != 'unset':
        connect_node(nodes, args.connect)
    elif args.iterm:
        iterm_profile(lab_json=nodes)
    else:
        table = list_topology_nodes(nodes)
        print(table)

    sys.exit(0)
